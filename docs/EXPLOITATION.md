# Exploitation Guide - UU Power & Light Attack Scenarios

Detailed usage guide for all attack demonstration scripts in the ICS simulator.

## Table of Contents

- [Attack Overview](#attack-overview)
- [Reconnaissance](#reconnaissance)
- [Disruption Attacks](#disruption-attacks)
- [Destruction Attacks](#destruction-attacks)
- [Data Exfiltration](#data-exfiltration)
- [Detection Evasion](#detection-evasion)
- [Multi-Stage Attacks](#multi-stage-attacks)
- [Defensive Countermeasures](#defensive-countermeasures)

## Attack overview

All attacks follow the ICS Kill Chain:
1. Reconnaissance → Gather intelligence
2. Weaponization → Craft attack
3. Delivery → Establish access
4. Exploitation → Execute attack
5. Installation → Maintain persistence
6. Command & Control → Remote control
7. Actions on Objectives → Achieve impact

The simulator focuses on Reconnaissance through Actions on Objectives.

## Reconnaissance

### turbine_reconnaissance.py

Purpose: Passive intelligence gathering without disrupting operations

What it does:
- Reads turbine setpoints and operational parameters
- Identifies safety thresholds and alarm limits
- Maps PLC register layout
- Establishes operational baselines

Usage:
```bash
python3 exploitation/turbine_reconnaissance.py
```

Configuration:
```python
# Edit at top of script
CONFIG = {
    'plc': {
        'ip': '127.0.0.1',  # Target PLC IP
        'port': 502
    }
}
```

Example output:
```
[*] Reading configuration from Turbine 1 (Demo) (127.0.0.1)...
    Speed Setpoint: 1500 RPM
    Current Speed: 1498 RPM
    Temperature Alarm: 95°C
    Current Temperature: 72°C
    E-Stop Active: False
    Temperature Safety Margin: 23°C

[*] Results saved to: poc_turbine_read_20251216_143022.json
[*] No modifications were made to any systems
```

Output Files:
- `poc_turbine_read_YYYYMMDD_HHMMSS.json` - Detailed reconnaissance data

MITRE ATT&CK mapping:
- T0840 - Network Connection Enumeration
- T0842 - Network Sniffing
- T0888 - Remote System Information Discovery

Key Intelligence Gathered:
- Operational setpoints (1500 RPM nominal)
- Safety margins (95°C temperature alarm)
- System architecture (Modbus register addresses)
- Current operational state

Detection Indicators:
- Modbus READ operations
- Typical HMI-style polling patterns
- No writes = low suspicion

## Disruption attacks

### turbine_emergency_stop.py

Purpose: Immediate shutdown of all turbines (high-impact disruption)

What it does:
- Connects to multiple turbines
- Writes `0` to speed setpoint register (1000)
- Causes immediate loss of power generation
- Simulates emergency stop scenario

Usage:
```bash
python3 exploitation/turbine_emergency_stop.py
```

Configuration:
```python
CONFIG = {
    'turbines': [
        '127.0.0.1',      # Local demo
        # '192.168.10.10',  # Real network testing
        # '192.168.10.11',
        # '192.168.10.12'
    ]
}
```

Example output:
```
[*] Targeting turbine at 127.0.0.1...
    Current setpoint: 1500 RPM
    [✓] Emergency stop executed
    New setpoint: 0 RPM

[*] ATTACK SUMMARY
Turbines targeted: 1
Successful attacks: 1

[*] IMPACT:
    • 1 turbine(s) forced to emergency stop
    • Immediate loss of power generation
    • Potential mechanical damage from rapid deceleration
    • Grid stability impact
```

Business impact:
- Immediate loss of revenue (power generation stopped)
- Potential equipment damage
- Grid instability
- Emergency response costs
- Reputational damage

MITRE ATT&CK mapping:
- T0816 - Device Restart/Shutdown
- T0881 - Service Stop
- T0809 - Data Destruction

Detection indicators:
- SCADA alarms trigger immediately
- Sudden loss of generation visible in logs
- Modbus WRITE to critical registers
- Multiple simultaneous write operations

## Destruction Attacks

### turbine_overspeed_attack.py

Purpose: Gradual manipulation to cause physical equipment damage

What it does:
- Slowly increases speed setpoint beyond safe limits
- Small increments (5 RPM) to avoid rate-of-change detection
- Targets 10% overspeed (1500 → 1650 RPM)
- Maintains changes over time

Usage:
```bash
python3 exploitation/turbine_overspeed_attack.py
```

Configuration:
```python
CONFIG = {
    'target_turbine': '127.0.0.1',
    'start_speed': 1500,      # Normal operating speed
    'target_speed': 1650,     # 10% overspeed
    'increment': 5,           # RPM per step
    'delay_seconds': 1        # Time between steps (demo uses 1s, real attack uses 60s)
}
```

Example output:
```
[*] Target: 127.0.0.1
[*] Current speed: 1500 RPM (normal)
[*] Target speed: 1650 RPM (10.0% overspeed)
[*] Total steps: 30

[14:52:30] Step 1/30: Setpoint = 1500 RPM (+0.0%)
[14:52:31] Step 2/30: Setpoint = 1505 RPM (+0.3%)
...
[14:52:59] Step 30/30: Setpoint = 1650 RPM (+10.0%)

[*] PHYSICAL DAMAGE ASSESSMENT:
    • Overspeed: 10.0% above normal
    • Centrifugal forces increased by ~21%
    • Potential outcomes:
      - Blade structural failure
      - Bearing damage from excessive loads
      - Gearbox destruction
      - Catastrophic turbine disintegration
```

Physics behind the attack:
- Centrifugal force = ω² (speed squared)
- 10% speed increase = 21% force increase
- Blades not designed for sustained overspeed
- Bearings fail under excessive load

MITRE ATT&CK mapping:
- T0836 - Modify Parameter
- T0806 - Brute Force I/O
- T0831 - Manipulation of Control

Detection indicators:
- Gradual setpoint drift
- Operating outside normal variance
- Cumulative time at elevated speeds
- Physics-based anomaly detection

Why  it is stealthy:
- Small changes don't trigger absolute threshold alarms
- Slow progression appears operational
- Stays below alarm thresholds temporarily
- Looks like normal engineering adjustment

## Data exfiltration

### covert_exfiltration.py

Purpose: Demonstrate techniques to steal data without detection

Methods Demonstrated:
1. DNS Tunneling - Data hidden in DNS queries
2. HTTPS Upload - Encrypted file uploads
3. Rate-Limited Exfiltration - Slow exfiltration to avoid DLP

Usage:
```bash
python3 exfiltration/covert_exfiltration.py
```

Example output:
```
[*] METHOD 1: DNS Tunneling
    Sending 5 DNS queries...
    Detection evasion: Appears as normal DNS lookups

[*] METHOD 2: HTTPS Upload
    Data size: 281 bytes
    Detection evasion: Encrypted, looks like normal web traffic

[*] METHOD 3: Time-Based Rate Limiting
    For 10 MB dataset:
    Time required: 102 hours (4.3 days)
    Detection risk: Minimal (blends with background)
```

MITRE ATT&CK mapping:
- T1048 - Exfiltration Over Alternative Protocol
- T1041 - Exfiltration Over C2 Channel
- T1030 - Data Transfer Size Limits

### historian_exfiltration.py

Purpose: Simulate extraction of historical operational data

What it targets:
- Production metrics (GWh generated)
- Efficiency data (% operational efficiency)
- Maintenance records
- Alarm histories

Example output:
```
[*] Connecting to historian at 192.168.3.10...
[*] Querying last 365 days of data...

[*] In a real scenario, this would extract:
    • Years of production data
    • Efficiency metrics and trends
    • Maintenance and downtime records
    • Alarm histories and patterns
```

Business value of stolen data:
- Competitive intelligence (how efficient are they?)
- Intellectual property (operational parameters)
- Contract information (production volumes)
- Strategic data (improvement trends)

### plc_logic_extraction.py

Purpose: Simulate theft of PLC ladder logic (intellectual property)

What it targets:
- Complete PLC programs
- Safety interlock logic
- Control algorithms
- Process recipes

Example output:

```
[*] EXAMPLE: What Attackers Learn from Ladder Logic

[*] Safety Interlocks Discovered:
    • Emergency stop circuit on input I:1/0
    • Temperature > 95C triggers shutdown
    • Pressure relief valve opens at 150 PSI

[*] Proprietary Process Parameters:
    • Proprietary mixing algorithm with 7-stage process
    • Temperature ramp rate: 2.5°C/min for optimal yield
    • Custom PID tuning parameters (Kp=1.2, Ki=0.8, Kd=0.3)

[*] Attack Vectors Identified:
    • Safety logic can be bypassed via register 1100
    • No authentication on remote I/O modules
```

Value to competitor:
- Years of engineering optimization
- Trade secrets
- Process know-how
- Ability to replicate entire operation

## Detection evasion

### anomaly_bypass_test.py

Purpose: Demonstrate attacks that evade anomaly detection systems

Strategy:
1. Learn normal patterns - Observe typical operations
2. Match timing - Use normal polling intervals
3. Stay within variance - Small changes only
4. Blend in - Appear as legitimate engineering activity

Usage:
```bash
python3 exploitation/anomaly_bypass_test.py
```

What it does:

Phase 1: Learning (5 cycles)
```
[*] Learning cycle 1/5
    Reading registers (appears as normal HMI polling)
    Poll interval: 1.0s (matches normal HMI)
```

Phase 2: Attack
```
[*] Current value: 1500 RPM
[*] Target value: 1490 RPM
[*] Variance: 10 RPM (max normal: 50 RPM)
[✓] Change is within normal operational variance
[✓] Setpoint modified: 1500 → 1490 RPM
```

Phase 3: Cover
```
[*] Continuing normal polling behavior
[*] Monitoring for 10 cycles
    (Maintains appearance of normal operations)
```

Example Output:
```
[*] TRAFFIC CHARACTERISTICS:
    ✓ Timing: Matches normal HMI polling (1s intervals)
    ✓ Frequency: Matches typical operations
    ✓ Packet size: Standard Modbus read/write
    ✓ Time of day: During business hours
    ✓ Change size: Within normal operational variance

[*] EXPECTED ANOMALY DETECTION RESULT:
    ✓ NO ALERTS - Traffic appears completely normal
```

MITRE ATT&CK mapping:
- T1562 - Impair Defenses
- T1070 - Indicator Removal
- T1027 - Obfuscated Files or Information

Why It Works:
- Anomaly detection looks for deviations from normal
- This attack IS the normal pattern
- Small changes stay within learned variance
- Timing matches legitimate traffic

## Multi-stage attacks

### siem_correlation_test.py

Purpose: Test whether SIEM systems correlate events into attack chains

Attack chain:

1. VPN login from unusual location (US instead of UK)
2. SSH brute force (10 failed attempts, then success)
3. RDP lateral movement to engineering workstation
4. Access to PLC configuration files
5. OT network scanning
6. Modbus connections to PLCs
7. Modbus WRITE commands (critical action)

Usage:
```bash
python3 exploitation/siem_correlation_test.py
```

Configuration:
```python
CONFIG = {
    'jump_server': {
        'ip': '127.0.0.1',
        'port': 22,
        'valid_username': 'admin',
        'valid_password': 'admin123',
        'invalid_passwords': ['password', '123456', 'admin', ...]
    },
    'ot_network': {
        'plc_ips': ['127.0.0.1']  # Adjust for your environment
    }
}
```

Example output:
```
[*] STEP 1: VPN Login from unusual location
    Expected: SIEM flags unusual geo-location

[*] STEP 2: SSH brute force attack
    Attempt 1: Trying password 'password'... FAILED
    Attempt 2: Trying password '123456'... FAILED
    ...
    Attempt 11: Trying valid password... SUCCESS
    Expected: SIEM detects brute force pattern

[*] STEP 6: Modbus PLC Connections
    Connecting to 127.0.0.1:502... CONNECTED
    Expected: SIEM logs unauthorized industrial protocol traffic

[*] STEP 7: Modbus WRITE Commands
    Writing new value: 1501... SUCCESS
    Expected: CRITICAL - OT control system modification

[*] EXPECTED SIEM BEHAVIOR:
    ✓ Each event logged individually
    ✓ Events correlated by source IP/username
    ✓ Attack chain pattern recognized (Kill Chain)
    ✓ High-priority correlated alert generated
```

MITRE ATT&CK Kill Chain:
- T1133 - External Remote Services (VPN)
- T1110 - Brute Force (SSH)
- T1021.001 - Remote Desktop Protocol
- T1005 - Data from Local System
- T1046 - Network Service Discovery
- T0885 - Unauthorized Command Message
- T0836 - Modify Parameter

Testing Checklist:
- [ ] Individual events logged
- [ ] Events correlated by source
- [ ] Kill chain recognized
- [ ] SOC notified
- [ ] Incident ticket created
- [ ] Appropriate severity assigned

## Defensive countermeasures

### Network segmentation
```
Internet
    ↓
Corporate Network
    ↓ (Firewall + IDS)
DMZ
    ↓ (Data Diode / Unidirectional Gateway)
OT Network (ISOLATED)
```

### Authentication & access control
- Multi-factor authentication for VPN
- Role-based access control (RBAC)
- Principle of least privilege
- Time-based access restrictions

### Monitoring & detection

```
# Example detection rule
if (protocol == "modbus" AND 
    function_code == "write" AND 
    source_ip NOT IN approved_engineers):
    ALERT("Unauthorised Modbus Write", severity="CRITICAL")
```

### Rate-of-change limits

```
# Prevent gradual overspeed attacks
if abs(new_value - old_value) > CHANGE_THRESHOLD:
    BLOCK_WRITE()
    ALERT("Excessive setpoint change")

# Also check cumulative changes
if sum(last_10_changes) > CUMULATIVE_THRESHOLD:
    ALERT("Gradual manipulation detected")
```

### Physics-based anomaly detection

```
# Detect impossible states
if speed_setpoint > MAX_SAFE_SPEED:
    ALARM("Overspeed setpoint")
    
if temperature > PHYSICAL_LIMIT:
    ALARM("Impossible temperature reading - sensor attack?")
```

### Write Authorisation

```
# Require approval for critical changes
if register in CRITICAL_REGISTERS:
    require_approval(engineer_1, engineer_2)
    log_with_attribution()
```

## Using these scripts responsibly

### ✅ Authorised uses

- Security training and education
- Penetration testing with written authorisation
- Red team exercises in isolated environments
- Research and development
- Security tool testing

### ❌ Prohibited uses

- Unauthorised access to systems
- Testing without permission
- Causing harm or disruption
- Theft of data or intellectual property
- Any illegal activity

### Best practices

1. Always get written authorization before testing
2. Use isolated environments (VMs, separate networks)
3. Document all activities (what, when, why)
4. Have a rollback plan (how to restore systems)
5. Coordinate with stakeholders (ops, security, management)
6. Follow responsible disclosure if you find real vulnerabilities

See [ARCHITECTURE.md](ARCHITECTURE.md) for technical details on how the simulator works.

*"Any sufficiently advanced attack is indistinguishable from legitimate operations." - ICS Security Proverb*
